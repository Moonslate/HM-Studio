#include "class_stc.hpp"

static uint8_t* error_rgb = new uint8_t[768]{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x2d, 0x2d, 0xdc, 0x49, 0x49, 0xee, 0x50, 0x50, 0xee, 0x50, 0x50, 0xee, 0x50, 0x50, 0xee, 0x50, 0x50, 0xdd, 0x4b, 0x4b, 0x8c, 0x2d, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x19, 0x19, 0xda, 0x48, 0x48, 0xea, 0x4f, 0x4f, 0xec, 0x4e, 0x4e, 0xec, 0x4f, 0x4f, 0xed, 0x50, 0x50, 0xed, 0x50, 0x50, 0xec, 0x4f, 0x4f, 0xec, 0x4e, 0x4e, 0xea, 0x4f, 0x4f, 0xdc, 0x48, 0x48, 0x4c, 0x19, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x19, 0x19, 0xe4, 0x4b, 0x4b, 0xea, 0x4e, 0x4e, 0xeb, 0x4f, 0x4f, 0xec, 0x4f, 0x4f, 0xed, 0x4f, 0x4f, 0xec, 0x4e, 0x4e, 0xec, 0x4e, 0x4e, 0xed, 0x4f, 0x4f, 0xec, 0x4f, 0x4f, 0xeb, 0x4f, 0x4f, 0xea, 0x4e, 0x4e, 0xe5, 0x4c, 0x4c, 0x4c, 0x19, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd7, 0x45, 0x45, 0xe8, 0x4c, 0x4c, 0xea, 0x4f, 0x4f, 0xf1, 0x99, 0x99, 0xf1, 0x98, 0x98, 0xeb, 0x4f, 0x4f, 0xeb, 0x4d, 0x4d, 0xeb, 0x4d, 0x4d, 0xeb, 0x51, 0x51, 0xf2, 0xa1, 0xa1, 0xf0, 0x8d, 0x8d, 0xea, 0x4e, 0x4e, 0xe8, 0x4c, 0x4c, 0xda, 0x46, 0x46, 0x00, 0x00, 0x00, 0x82, 0x28, 0x28, 0xe6, 0x4b, 0x4b, 0xe8, 0x4c, 0x4c, 0xf0, 0x98, 0x98, 0xf9, 0xf6, 0xf6, 0xf9, 0xf7, 0xf7, 0xf2, 0xa8, 0xa8, 0xea, 0x4e, 0x4e, 0xea, 0x50, 0x50, 0xf3, 0xb8, 0xb8, 0xf9, 0xf7, 0xf7, 0xf8, 0xf5, 0xf5, 0xee, 0x87, 0x87, 0xe8, 0x4c, 0x4c, 0xe6, 0x4b, 0x4b, 0x87, 0x2d, 0x2d, 0xd2, 0x42, 0x42, 0xe6, 0x48, 0x48, 0xe7, 0x4a, 0x4a, 0xe9, 0x92, 0x92, 0xf8, 0xf6, 0xf6, 0xf9, 0xf8, 0xf8, 0xf9, 0xf7, 0xf7, 0xf2, 0xa9, 0xa9, 0xf3, 0xb8, 0xb8, 0xf9, 0xf8, 0xf8, 0xf9, 0xf8, 0xf8, 0xf7, 0xf4, 0xf4, 0xe8, 0x83, 0x83, 0xe7, 0x4a, 0x4a, 0xe6, 0x48, 0x48, 0xd7, 0x44, 0x44, 0xe6, 0x47, 0x47, 0xe5, 0x47, 0x47, 0xe6, 0x48, 0x48, 0xe6, 0x4a, 0x4a, 0xe7, 0x9f, 0x9f, 0xf8, 0xf6, 0xf6, 0xf9, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf8, 0xf8, 0xf7, 0xf5, 0xf5, 0xe5, 0x90, 0x90, 0xe7, 0x49, 0x49, 0xe6, 0x48, 0x48, 0xe5, 0x47, 0x47, 0xe6, 0x47, 0x47, 0xe5, 0x45, 0x45, 0xe4, 0x46, 0x46, 0xe5, 0x46, 0x46, 0xe5, 0x47, 0x47, 0xe5, 0x49, 0x49, 0xe7, 0xa2, 0xa2, 0xf9, 0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xf9, 0xf9, 0xf9, 0xf8, 0xf7, 0xf7, 0xe5, 0x90, 0x90, 0xe5, 0x49, 0x49, 0xe5, 0x47, 0x47, 0xe5, 0x46, 0x46, 0xe4, 0x46, 0x46, 0xe5, 0x45, 0x45, 0xe3, 0x45, 0x45, 0xe2, 0x45, 0x45, 0xe3, 0x45, 0x45, 0xe4, 0x45, 0x45, 0xe4, 0x4a, 0x4a, 0xf1, 0xb6, 0xb6, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf8, 0xf8, 0xef, 0xa6, 0xa6, 0xe4, 0x47, 0x47, 0xe4, 0x45, 0x45, 0xe3, 0x45, 0x45, 0xe2, 0x45, 0x45, 0xe3, 0x45, 0x45, 0xe0, 0x47, 0x47, 0xe0, 0x44, 0x44, 0xe2, 0x44, 0x44, 0xe2, 0x47, 0x47, 0xf0, 0xb5, 0xb5, 0xf9, 0xf8, 0xf8, 0xf9, 0xf8, 0xf8, 0xf7, 0xf6, 0xf6, 0xf8, 0xf7, 0xf7, 0xf9, 0xf8, 0xf8, 0xf9, 0xf7, 0xf7, 0xee, 0xa4, 0xa4, 0xe2, 0x46, 0x46, 0xe2, 0x44, 0x44, 0xe0, 0x44, 0x44, 0xe0, 0x47, 0x47, 0xc8, 0x44, 0x44, 0xdf, 0x40, 0x40, 0xe0, 0x43, 0x43, 0xec, 0x9c, 0x9c, 0xf9, 0xf7, 0xf7, 0xf9, 0xf8, 0xf8, 0xf7, 0xf5, 0xf5, 0xe2, 0x8d, 0x8d, 0xe4, 0x9e, 0x9e, 0xf8, 0xf6, 0xf6, 0xf9, 0xf8, 0xf8, 0xf9, 0xf6, 0xf6, 0xe9, 0x8a, 0x8a, 0xe0, 0x42, 0x42, 0xdf, 0x40, 0x40, 0xce, 0x47, 0x47, 0x78, 0x2d, 0x2d, 0xdc, 0x41, 0x41, 0xdd, 0x41, 0x41, 0xe2, 0x82, 0x82, 0xf7, 0xf3, 0xf3, 0xf7, 0xf4, 0xf4, 0xe1, 0x8b, 0x8b, 0xdf, 0x42, 0x42, 0xdf, 0x42, 0x42, 0xe3, 0x9c, 0x9c, 0xf8, 0xf5, 0xf5, 0xf6, 0xf0, 0xf0, 0xe1, 0x73, 0x73, 0xdd, 0x40, 0x40, 0xdc, 0x41, 0x41, 0x7d, 0x32, 0x32, 0x00, 0x00, 0x00, 0xc7, 0x46, 0x46, 0xdb, 0x3f, 0x3f, 0xdc, 0x41, 0x41, 0xde, 0x7a, 0x7a, 0xde, 0x79, 0x79, 0xdd, 0x40, 0x40, 0xdd, 0x3f, 0x3f, 0xde, 0x3f, 0x3f, 0xdd, 0x41, 0x41, 0xde, 0x82, 0x82, 0xdd, 0x70, 0x70, 0xdd, 0x40, 0x40, 0xdb, 0x3f, 0x3f, 0xca, 0x48, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x19, 0x19, 0xd3, 0x47, 0x47, 0xd9, 0x3d, 0x3d, 0xda, 0x3d, 0x3d, 0xdb, 0x3d, 0x3d, 0xdc, 0x3d, 0x3d, 0xdc, 0x3d, 0x3d, 0xdc, 0x3d, 0x3d, 0xdc, 0x3d, 0x3d, 0xdb, 0x3d, 0x3d, 0xda, 0x3d, 0x3d, 0xd9, 0x3d, 0x3d, 0xd3, 0x47, 0x47, 0x4c, 0x19, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x19, 0x19, 0xc5, 0x46, 0x46, 0xd7, 0x3d, 0x3d, 0xd9, 0x3c, 0x3c, 0xd9, 0x3c, 0x3c, 0xd9, 0x3c, 0x3c, 0xd9, 0x3c, 0x3c, 0xd9, 0x3c, 0x3c, 0xd9, 0x3c, 0x3c, 0xd7, 0x3d, 0x3d, 0xc7, 0x48, 0x48, 0x4c, 0x19, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x2d, 0x2d, 0xc1, 0x44, 0x44, 0xd8, 0x46, 0x46, 0xd9, 0x41, 0x41, 0xd9, 0x41, 0x41, 0xd8, 0x46, 0x46, 0xc4, 0x46, 0x46, 0x78, 0x32, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static uint8_t* error_alpha = new uint8_t[256]{ 0x00, 0x00, 0x00, 0x01, 0x33, 0x99, 0xda, 0xf9, 0xf9, 0xda, 0x99, 0x33, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x9b, 0xfb, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xfd, 0xfb, 0x9b, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0xc1, 0xfd, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfd, 0xc1, 0x0a, 0x00, 0x01, 0x9b, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0x9b, 0x01, 0x33, 0xfb, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0x33, 0x99, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0x99, 0xda, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xda, 0xf9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf9, 0xf9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf9, 0xda, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xda, 0x99, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0x99, 0x33, 0xfb, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0x33, 0x01, 0x9b, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0x9b, 0x01, 0x00, 0x0a, 0xc1, 0xfd, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfd, 0xc1, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0x9b, 0xfb, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xfd, 0xfb, 0x9b, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x33, 0x99, 0xda, 0xf9, 0xf9, 0xda, 0x99, 0x33, 0x01, 0x00, 0x00, 0x00 };

wxBitmap STC::m_sIconError(wxImage(16, 16, error_rgb, error_alpha, true));

STC::STC(wxWindow* parent, wxWindowID id) : wxStyledTextCtrl(parent, id)
#ifdef USESPELL
, m_Timer()
#endif
{
	CreateGUI();
	DoBinds();

#ifdef USESPELL
	m_Timer.Start(m_TimeToType);
#endif
}

STC::~STC()
{
#ifdef USESPELL
	if (m_DeleteHunspell)
		delete m_Hunspell;
#endif
}

inline void STC::VerifyLineLenght(size_t line)
{	
	if (m_MaxLineLenght == UINT32_MAX)
		return;

	int lenght = this->GetLineLength(line);	

	if (lenght > m_MaxLineLenght)
	{
		if (!(this->MarkerGet(line) & STC_MARK_ERROR_MASK)) //Verify if the line already has that marker
			this->MarkerAdd(line, STC_MARK_ERROR);
	}
	else if (this->MarkerGet(line) & STC_MARK_ERROR_MASK)
		this->MarkerDelete(line, STC_MARK_ERROR);	
}

inline void STC::VerifyLineLenghtFromPos(size_t from, size_t to)
{		
	size_t fromLine = LineFromPosition(from);
	size_t toLine =   LineFromPosition(to);

	do
	{
		VerifyLineLenght(fromLine);
		++fromLine;
	} while (fromLine <= toLine);
}

inline void STC::VerifyCurLineLenght()
{
	VerifyLineLenght(GetCurrentLine());
}

inline void STC::Highlight(size_t start, size_t lenght, int style)
{	
//
//	The StartStyling(int pos, int mask) is deprecated under wxMSW,
//	but is still in use in wxGTK+ 
//

#ifdef __WXMSW__
	StartStyling(start);
#else ifdef __WXGTK__	
	StartStyling(start, 31);
#endif	
	SetStyling(lenght, style);
}

inline void STC::HighlightAll(const std::vector<size_t>& indexes, size_t lenght, int style)
{
	for (size_t index : indexes)
		Highlight(index, lenght, style);
}

inline void STC::FindAll(size_t start, size_t end, const std::string& s, std::vector<size_t>& result)
{	
	int pos = FindText(start, end, s);
	size_t sSize = s.size();

	if (start > end)
	{
		std::swap(start, end);
	}

	while (pos != -1)
	{
		result.push_back(pos);
		pos = FindText(pos + sSize, end, s);
	}
}

inline void STC::FindAndStyleAllVars(size_t start, size_t end)
{
	for (const std::string& s : m_Vars)
	{
		std::vector<size_t> indexes;
		FindAll(start, end, s, indexes);
		HighlightAll(indexes, s.size(), STC_STYLE_VAR);
	}
}

void STC::SetUserCanAddLine(bool can)
{
	m_UserCanAddLine = can;
}

void STC::OnKeyPress(wxKeyEvent& event)
{
	char key = event.GetUnicodeKey();
	int keyCode = event.GetKeyCode();
	bool ctrl = event.GetModifiers() == wxMOD_CONTROL;

	if (ctrl && keyCode != wxKeyCode::WXK_CONTROL)
	{
		size_t pos = m_Keys.find(key, 0);

		if (pos != std::string::npos)
		{
			InsertText(GetCurrentPos(), m_StringsOnKey[pos]);
			GotoPos(GetCurrentPos() + m_StringsOnKey[pos].size());
		}
	}
	else if (!m_UserCanAddLine)
	{
		if (keyCode != wxKeyCode::WXK_RETURN && keyCode != wxKeyCode::WXK_NUMPAD_ENTER)
		{
			return;
		}
	}

	event.Skip();
}

void STC::OnStyleNeeded(wxStyledTextEvent& event)
{	
	if (m_NeedStyle)
	{
		size_t start = PositionFromLine(LineFromPosition(m_TypingStart));
		size_t end = GetLineEndPosition(LineFromPosition(m_TypingEnd));

		Highlight(start, end, STC_STYLE_TEXT);
		FindAndStyleAllVars(start, end);
		VerifyLineLenghtFromPos(start, end);

		m_NeedStyle = false;
	}

	event.Skip();
}

#ifdef USESPELL
inline void STC::SpellSTC()
{
	if (m_Hunspell == nullptr)
		return;

	if (!m_NeedToSpell)
		return;

	m_NeedToSpell = false;

	if (GetTextLength() <= 1) //no needs to spell
		return;

	SetIndicatorCurrent(STC_INDIC_SPELL);	

	size_t start = WordStartPosition(m_TypingStart, true);

	IndicatorClearRange(start, WordEndPosition(m_TypingEnd, true) - start);	

	size_t curPosition = start;

	while (curPosition < m_TypingEnd)
	{
		size_t wordStart = WordStartPosition(curPosition, true);
		size_t wordEnd = WordEndPosition(curPosition, true);

		size_t wordSize = wordEnd - wordStart;

		curPosition += wordSize + 1;				

		std::string word = GetTextRange(wordStart, wordEnd).ToStdString();

		if (word.size() < 2)
			continue;
		
		if (!m_Hunspell->spell(word))
			IndicatorFillRange(wordStart, wordSize);
	}
}
#endif

//-------------------------------------------------------------------------------------//
//Events
//-------------------------------------------------------------------------------------//

void STC::OnModified(wxStyledTextEvent& event)
{			
	size_t textLenght = event.m_length;

	bool deletedAll = false;

#ifndef _DEBUG
	if (event.m_modificationType & wxSTC_MOD_BEFOREDELETE) //user deleted the text
	{
		if (textLenght == GetTextLength()) //and actually all the text
		{
			if (GetLineCount() == 1) //and the STC has one line only
			{
				Refresh(); //solving a bug
				deletedAll = true;
			}
		}
	}
#endif // !1

	if (!deletedAll)
	{				
		size_t textPos = event.m_position;		

		if (!m_Typing) //User is not typing
		{
			m_TypingStart = textPos;
			m_TypingEnd = textPos + textLenght;

#ifdef USESPELL
			m_NeedToSpell = true;
#endif // USESPELL			
		}
		else
		{
			if (textPos < m_TypingStart)
				m_TypingStart = textPos;

			if (textPos > m_TypingEnd)
				m_TypingEnd = textPos;
		}

		m_NeedStyle = true;

		m_Timer.Start();
	}

	event.Skip();
}

void STC::OnMouseRight(wxMouseEvent& event)
{
	ShowMenu(event.GetPosition());
	//this->SetText(wxString() << PositionFromPoint(event.GetPosition()));
	//event.Skip();
}

void STC::InsertOnCtrlKey(const std::string& s, char key)
{
	if (!MathUtil::IsInsideBlock(key, 61, 26))
		return;

	size_t index = m_Keys.find(key, 0);

	if (index != std::string::npos)
	{
		m_StringsOnKey[index] = s;
	}
	else
	{
		m_StringsOnKey.push_back(s);
		m_Keys.push_back((uint16_t)key);
	}
}

#ifdef USESPELL
void STC::SetHunspell(Hunspell* hunspell, bool canDelete)
{
	m_DeleteHunspell = canDelete;

	if (m_Hunspell != nullptr)
		delete m_Hunspell;

	m_Hunspell = hunspell;
}
#endif

void STC::OnTimer(wxTimerEvent& event)
{
#ifdef USESPELL
	SpellSTC();
#endif // USESPELL	
	m_Typing = false;
}

//Menu
void STC::ShowMenu(wxPoint point)
{
	SuggestToMenu(point);
	PopupMenu(m_pMenu, point.x, point.y);
}

void STC::SuggestToMenu(wxPoint point)
{
#ifdef USESPELL
	//Removing old suggestions
	for (size_t i = 0; i < m_MenuIds.size(); ++i)
	{
		m_pMenu->Remove(m_MenuIds[i]);
	}

	m_MenuIds.clear();

	if (GetTextLength() >= 2)
	{
		size_t position = PositionFromPoint(point);
		size_t start = WordStartPosition(position, false);
		size_t end = WordEndPosition(position, false);

		if (IndicatorValueAt(STC_INDIC_SPELL, start))
		{
			std::string s = GetTextRange(start, end).ToStdString();

			if (s.size() >= 2)
			{
				std::vector<std::string> strings = m_Hunspell->suggest(s);

				if (strings.size() > 0)
				{
					m_MenuIds.clear();
					m_MenuIds.reserve(strings.size() + 2);

					m_MenuIds.push_back(m_pMenu->Append(wxID_EXECUTE, wxString("Ignore \"") << s << "\" For Current Session")->GetId());
					m_MenuIds.push_back(m_pMenu->Append(wxID_EXIT, wxString("Add \"") << s << "\" To Dictionary")->GetId());
					m_MenuIds.push_back(m_pMenu->AppendSeparator()->GetId());

					for (size_t i = 0; i < strings.size(); ++i)
					{
						m_MenuIds.push_back(m_pMenu->Append(wxID_FILE + i, strings[i])->GetId());
					}

					m_ClickedWord.first = start;
					m_ClickedWord.second = end;
				}
			}
		}
	}
#endif // USESPELL
}

void STC::OnMenuClick(wxCommandEvent& event)
{
	size_t id = event.GetId();

	DeleteRange(m_ClickedWord.first, m_ClickedWord.second - m_ClickedWord.first);
	GotoPos(m_ClickedWord.first);
	AddText(m_pMenu->FindItem(id)->GetItemLabelText());

	event.Skip();
}

void STC::DoBinds()
{
	this->Bind(wxEVT_STC_STYLENEEDED, &STC::OnStyleNeeded, this);
	this->Bind(wxEVT_STC_MODIFIED, &STC::OnModified, this);
	this->Bind(wxEVT_RIGHT_UP, &STC::OnMouseRight, this);
	this->Bind(wxEVT_KEY_DOWN, &STC::OnKeyPress, this);

	m_Timer.Bind(wxEVT_TIMER, &STC::OnTimer, this);
	m_pMenu->Bind(wxEVT_MENU, &STC::OnMenuClick, this);
}

void STC::CreateGUI()
{
	this->SetLexer(wxSTC_LEX_CONTAINER);

	//this->StyleSetBackground(STC_STYLE_TEXT, Studio::GetControlBackgroundColor());
	//this->StyleSetBackground(STC_STYLE_VAR, Studio::GetControlBackgroundColor());
	//this->StyleSetBackground(STC_STYLE_SIMBOL, Studio::GetControlBackgroundColor());
	//this->StyleSetBackground(32, Studio::GetControlBackgroundColor()); //The editor background

	this->StyleSetFont(STC_STYLE_TEXT, Studio::GetDefaultFont());
	this->StyleSetFont(STC_STYLE_VAR, Studio::GetDefaultFont());
	this->StyleSetFont(STC_STYLE_SIMBOL, Studio::GetDefaultFont());

	//this->StyleSetForeground(STC_STYLE_TEXT, Studio::GetFontColour());
	//this->StyleSetForeground(STC_STYLE_VAR, wxColour(86, 156, 214));
	this->StyleSetForeground(STC_STYLE_VAR, wxColour(0, 0, 255));
	this->StyleSetBold(STC_STYLE_VAR, true);
	//this->StyleSetForeground(STC_STYLE_SIMBOL, wxColour(78, 201, 176));
	this->StyleSetForeground(STC_STYLE_SIMBOL, wxColour(0, 128, 0));
	this->StyleSetBold(STC_STYLE_SIMBOL, true);

	this->MarkerDefineBitmap(STC_MARK_ERROR, m_sIconError);

	this->SetMarginWidth(0, 32);
	this->SetMarginType(0, wxSTC_MARGIN_NUMBER);

	this->SetCaretForeground(Studio::GetFontColour());

	this->IndicatorSetStyle(STC_INDIC_FIND, wxSTC_INDIC_ROUNDBOX);
	this->IndicatorSetForeground(STC_INDIC_FIND, wxColour(17, 61, 111));
	this->IndicatorSetUnder(STC_INDIC_FIND, true);
	this->IndicatorSetAlpha(STC_INDIC_FIND, 255);	

	IndicatorSetStyle(STC_INDIC_SPELL, wxSTC_INDIC_SQUIGGLE);
	IndicatorSetForeground(STC_INDIC_SPELL, wxColour(236, 55, 55));
	IndicatorSetUnder(STC_INDIC_SPELL, true);
	IndicatorSetAlpha(STC_INDIC_SPELL, 255);

	SetModEventMask(wxSTC_MOD_INSERTTEXT | wxSTC_MOD_DELETETEXT | wxSTC_MOD_BEFOREDELETE);

	m_pMenu = new wxMenu();
	m_pMenu->Append(wxID_CUT, "Cut");
	m_pMenu->Append(wxID_COPY, "Copy");
	m_pMenu->Append(wxID_PASTE, "Paste");
	m_pMenu->Append(wxID_DELETE, "Delect");
	m_pMenu->Append(wxID_SELECTALL, "Select All");	
	m_pMenu->AppendSeparator();
}
